# **Compiler Explorer Tool**
1. Compiler Explorer, also known as godbolt.org, is an online tool for analyzing assembly output generated by 
 compilers.
2. It allows developers to explore how high-level code translates into low-level assembly instructions.
3. Useful for understanding compiler behavior, optimizing code, and comparing compiler output.

## **RISC-V Assembly Instructions**

RISC-V (Reduced Instruction Set Computing - V) is an open-source instruction set architecture (ISA) based on a simplified and modular design. It has different instruction formats, and assembly language instructions are represented by various opcodes. Below are some common RISC-V assembly instructions, along with brief explanations:

    **Arithmetic and Logical Instructions:**
        ADD rd, rs1, rs2: Adds the values in registers rs1 and rs2 and stores the result in register rd.
        SUB rd, rs1, rs2: Subtracts the value in register rs2 from rs1 and stores the result in register rd.
        AND rd, rs1, rs2: Bitwise AND of the values in registers rs1 and rs2, storing the result in register rd.
        OR rd, rs1, rs2: Bitwise OR of the values in registers rs1 and rs2, storing the result in register rd.
        XOR rd, rs1, rs2: Bitwise XOR of the values in registers rs1 and rs2, storing the result in register rd.

    **Data Transfer Instructions:**
        LW rd, offset(rs1): Loads a 32-bit word from memory at the address (rs1 + offset) and stores it in register rd.
        SW rs2, offset(rs1): Stores the value in register rs2 to memory at the address (rs1 + offset).

    **Control Flow Instructions:**
        JAL rd, offset: Jumps to the address (PC + offset) and stores the return address (PC + 4) in register rd.
        JALR rd, rs1, offset: Jumps to the address (rs1 + offset) and stores the return address (PC + 4) in register rd.
        BEQ rs1, rs2, offset: Branches to the address (PC + offset) if the values in registers rs1 and rs2 are equal.
        
    **Immediate Instructions:**
        ADDI rd, rs1, imm: Adds the immediate value imm to the value in register rs1 and stores the result in register rd.
        LUI rd, imm: Loads the immediate value imm into the upper 20 bits of register rd.

    **Comparison Instructions:**
        SLT rd, rs1, rs2: Sets rd to 1 if the value in register rs1 is less than rs2; otherwise, sets rd to 0.
        SLTI rd, rs1, imm: Sets rd to 1 if the value in register rs1 is less than the immediate value imm; otherwise, sets rd to 0.

  ## **Counter Program in 'C':**
   1. C code for 4 bit Counter

```
//#include <stdio.h>
#include <time.h>

void delay(int n) {
    int us = n; // microseconds
    clock_t start_time = clock();
    while (clock() < start_time + (us * CLOCKS_PER_SEC / 1000000));
}

void display(int count) // Function to display the data on the four Led's
{
	printf("Count value is: %d\n", count);						
}

int main()
{
	int count = 0x00000000;
	while (1)
	{
		display(count);
		count++;
        if(count==16){
            count=0;
        }
		delay(500000);   // delay by 0.5 microseconds
	}
}
```
   3. Implemented a 4 bit counter in C code and analyzed assembly output for RISC-V 32 gcc and X86-G4 gcc 13.2.
   4. Explored compiler handling of control flow and variable manipulation tasks.
![Counter](https://github.com/Daniel4bit/RISC-V_HDP/assets/65249875/b8d0930e-dd86-4213-96c3-462c51b6f275)

   ## **Matric Multiplication in 'C':**
   1. C code for 2D Matrix Multiplication
      ```
      // C program to multiply two matrices

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// Edit MACROs here, according to your Matrix Dimensions for
// mat1[R1][C1] and mat2[R2][C2]
#define R1 2 // number of rows in Matrix-1
#define C1 2 // number of columns in Matrix-1
#define R2 2 // number of rows in Matrix-2
#define C2 2 // number of columns in Matrix-2

void mulMat(int mat1[][C1], int mat2[][C2])
{
	int rslt[R1][C2];

	printf("Multiplication of given two matrices is:\n");

    clock_t start_time, end_time;

    start_time = clock() ; 

	for (int i = 0; i < R1; i++) {
		for (int j = 0; j < C2; j++) {
			rslt[i][j] = 0;

			for (int k = 0; k < R2; k++) {
				rslt[i][j] += mat1[i][k] * mat2[k][j];
			}

			printf("%d\t", rslt[i][j]);
		}

		printf("\n");
	}

    end_time = clock() ; 
    printf("Total time taken in seconds %d:\n", end_time - start_time);

}

// Driver code
int main()
{
	// R1 = 4, C1 = 4 and R2 = 4, C2 = 4 (Update these
	// values in MACROs)
	int mat1[R1][C1] = { { 1, 1 },
						{ 2, 2 } };

	int mat2[R2][C2] = { { 1, 1 },
						{ 2, 2 } };


	if (C1 != R2) {
		printf("The number of columns in Matrix-1 must be "
			"equal to the number of rows in "
			"Matrix-2\n");
		printf("Please update MACROs value according to "
			"your array dimension in "
			"#define section\n");

		exit(EXIT_FAILURE);
	}

	// Function call
	mulMat(mat1, mat2);

	return 0;
}
```
   3. Implemented a 2D MAtrix Multiplication in C code and analyzed assembly output for RISC-V 32 gcc and X86-G4 gcc 13.2.
   4. Explored compiler handling of control flow and variable manipulation tasks.
![Matrix](https://github.com/Daniel4bit/RISC-V_HDP/assets/65249875/03350bb5-7c1b-40a0-b972-9b2477cda923)



